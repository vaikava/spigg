<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <title>spigg.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <!-- <link rel="stylesheet" href="css/base.css"> !-->
  <link rel="stylesheet" href="css/skeleton.css"/>
  <link rel="stylesheet" href="css/layout.css">
  <link rel="stylesheet" href="css/spigg.css"/>
  <link rel="stylesheet" media="all" type="text/css" href="css/themes/obsidian.css" />
  <link rel="shortcut icon" href="spigg.ico"/>

  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>
<body>

<div class="container">
  <div class="sixteen columns">
    <h1>spigg.js</h1>
  </div>
  <div class="sixteen columns">
	
	<h3>Introduction</h3>
	<p>
	  <em>spigg</em> brings the <a href="http://martinfowler.com/eaaCatalog/dataMapper.html">data mapper pattern</a> to node.js
	  by introducing <em>entities</em> for your business logic and <em>mappers</em> to handle persistence. 
	  The result is modular, testable code to which DRY principles apply .<br /><br />
	<em>spigg.js</em> ships with a minimal featureset to get out of your way and doesn't care
	about how you choose to store your data or what business logic your application requires. <br />
	
	<h3>Install</h3>
      <pre><code>$ npm install spigg</code></pre>
	<p>
	  Running the above command in your shell will install the latest stable version
	  of <em>spigg</em>, which currently is <small><code>0.8.0</code></small>. <br />
	</p>
  </div>
  
  <div class="sixteen columns">
  	
  	<h3>Why?</h3>
  	<p>
      We needed to apply business logic to data, regardless of whether the data originated from a
  	  <em>REST API</em>, <em>in-memory-storage</em> or a <em>persistent database</em>. 
  	  <br />
  	  The <a href="http://martinfowler.com/eaaCatalog/dataMapper.html">data-mapper</a>
  	  pattern allowed for per-resource separation between datasource code and 
  	  business logic, so we decided to roll our own solution as no available library at the time did fit our needs.<br />
  	  As a bonus our codebase became even more modular, whilst adding minimal complexity.
	</p>
  	
  	<p>
  	  Centralizing business logic into entities makes a lot of sense, as you can always fire up
  	  an entity and invoke the custom business logic you defined in it. <br />
    </p>
    
    <p>
      When working with user submitted data, using a lot of <code>setters</code> isn't unusual. Setting
      email addresses to lowercase and trimming off spaces, for instance. With <em>spigg</em> setters on any
      depth are automatically recognized and run whenever the assigned property changes.g
    </p>
    
  	<h3>Quick example</h3>

<pre>
<code data-language="coffeescript"># /entities/User.coffee
s = require("spigg")
class User extends s.Entity

  # Call the init method which is automatically
  # invoked upon construction by the SpiggEntity
  init: ->
    # Optional:
    # Set a object of fields that are allowed in this entity to
    # prevent non-permitted properties from being stored.
    # This is helpful to when you need to build an entity out of 
    # user submitted data.
    @fields =
      name:    true
      email:   true
      tweets:  true
      meta:
        lastlogin: true

    # Optional:
    # Create a hashmap of default properties to be used in
    # the entity.
    @defaults =
      tweets:  []
      meta:
        lastlogin: new Date()
      
    # Optional: 
    # Store setters that is automatically invoked when you store a property
    # to your entity. In this example, all stored names will be lowercased.
    # Note that setters work on depth as well, so you could define nested setters.
    @setters = 
      name: (str) ->
        str.toLowerCase()

    # Here goes your business logic
    # Example:
    isValid: (callback) ->
      errors = []
      errors.push "Name is missing" unless @data.name
      callback(errors, @data)

module.exports.User = User</code>
</pre>
  
<pre><code data-language="coffeescript"># /mappers/User.coffe
s = require("spigg")
r = require("requestah")(80)
class UserMapper extends s.Mapper

  getByEmail: (email, callback) ->
    callback mysql.query("SELECT * FROM USERS WHERE EMAIL="+email)
  
  getTweets: (twitterUsername, callback) ->
    url = [
      "https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=",
      twitterUsername,
      "&count=100"
    ]
    
    r.get url.join(""), (res) ->
      callback res.body

  save: (user, callback) ->
    callback mysql.query("INSERT INTO USERS...")


module.exports.UserMapper = new UserMapper </code>
</pre>

<pre>
<code data-language="coffeescript"># /app.coffee  
express = require("express")
app =     express()
app.use express.bodyParser()

app.post "/users", (req, res) ->
  user =       require("./entities/Users")
  userMapper = require("./mappers/Users")
  user =       new User req.body

  user.isValid (err, data) ->
    userMapper.save user
    return res.send 201 unless err
    res.send JSON.stringify(err), 400

app.listen 3000 
</code></pre>

    <p>Above is written in coffeescript. Please use <a href="http://js2coffee.org/">this tool</a> to convert to plain JS.</p>

  </div>
	
	
  <div class="sixteen columns">	
	<h3>Documentation: Entity</h3>
	
	<h4>Creating entities</h4>
	<p>Create your own entity by extending the <code>Entity</code>-class provided by spigg, as shown below:</p>
	
<pre><code data-language="coffeescript">s = require("spigg")
class myEntity extends s.Entity	
</code></pre>

	<h4>Get &amp; set data</h4>
<p>Set data by passing arguments to the constructor</p>
<pre><code data-language="coffeescript">u = new user(name: "John Doe")
</code></pre>	

<p>Set data by key/value</p>
<pre><code data-language="coffeescript">u.set "name", "Jane Doe"
</code></pre>

<p>Set data by object</p>
<pre><code data-language="coffeescript">u.set {name: "Jane Doe"}
</code></pre>

<p>Get all data</p>
<pre><code data-language="coffeescript">u.get()
</code></pre>

<p>Get data by key</p>
<pre><code data-language="coffeescript">u.get("name")
</code></pre>

<p>Get data by dot notation</p>
<pre><code data-language="coffeescript">u.get("meta.lastlogin")
</code></pre>

<p>Unset a property from the entity</p>
<pre><code data-language="coffeescript">u.unset("name")
</code></pre>

<p>Reset the entity back to default values</p>
<pre><code data-language="coffeescript">u.reset()
</code></pre>

<p>Clear the entity</p>
<pre><code data-language="coffeescript">u.clear() # All properties are now removed.
</code></pre>		
	
	<h4>Allowed fields</h4>
	<p>
	  Create a property inside the <code>init</code>-method, named <code>fields</code> which should
	  represent the structure of your data.
	  By default any properties are allowed unless the <code>fields</code>-object has been set. <br />
	</p>
	
<pre><code data-language="coffeescript">s = require("spigg")
class myEntity extends s.Entity	
  init: ->
    # This entity can now only contain name, tweets & meta.lastlogin. Everything else is rejected.
    @fields =
      name:    true
      tweets:  true
      cats:    false
      meta:
        lastlogin: true
</code></pre>

	<h4>Custom setters</h4>
	<p>
	  Add setters inside the <code>init</code>-method as a representation of how your
	  data is organized. Setters are automatically invoked when a property changes and
	  modifies the value of said property accordingly.
	</p>
<pre><code data-language="coffeescript">s = require("spigg")
class myEntity extends s.Entity	
  init: ->
    @setters =
      name: (str) ->
        str.toLowerCase()
      meta: 
        lastlogin: (timestamp) ->
          new Date(timestamp*1000)
</code></pre>	

	<h4>Calling the filter method</h4>	
	<p>
	  In certain cases, it is preferably to not allow updates of all properties, so you can write your own
	  impmentation of the <code>_filter</code>-method already available in the entity to remove non-permitted fields as
	  shown below:
	</p>

<pre><code data-language="coffeescript">
class myEntity extends s.Entity

  @fieldsAllowedInUpdate:
    name:  true
    email: true
  
  isValidForUpdate: (callback) ->
    errors = []
    errors.push "Name is missing" unless @data.name
    callback(errors, @_filter(@data, @fieldsAllowedInUpdate))
	
</code></pre>

  <div class="sixteen columns">	
	<h3>Documentation: Mapper</h3>
	
	<h4>Creating mappers</h4>
	<p>Create your own mapper by extending the <code>Mapper</code>-class provided by spigg, as shown below:</p>
	
<pre><code data-language="coffeescript">s = require("spigg")
class myMapper extends s.Mapper
</code></pre>


	<h4>Ensure origin of data</h4>
	<p>
	  Mappers should generally not be aware of entities, but this is a good exception if you need to make sure
	  that data passed to a method inside a <code>mapper</code> must origin from an entity. Invoke the provided
	  <code>isEntity</code>-method as shown below accordingly:
	</p>

<pre><code data-language="coffeescript">s = require("spigg")
class myMapper extends s.Mapper
  save: (user) ->
    db.save user.data if @isEntity user	
</code></pre>
	
	

</div>	
	
  <div class="sixteen columns">	
  	<h3>Development</h3>
	<p><em>spigg</em> is released under the MIT license and is <a href="https://github.com/vaikava/spigg">hosted at Github</a>, so 
	feel free to contribute.
	</p>
	
	<p>To run tests;</p>
	<pre><code>$ make test</code></pre>
	
	<p>
		<strong>Roadmap:</strong>
	<ul>
	  <li>Better event support</li>
	  <li>Dot notation setter</li>
	</ul>
	</p>
  </div>
  

</div>
</body>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
  <script type="text/javascript" src="js/rainbow-custom.min.js"></script>
</html>
